# =================================================================================
#               Universal Windows Deployment Tool - FINAL REBUILT VERSION (v9)
#               Re-engineered from scratch for stability, clarity, and reliability.
# =================================================================================

# --- [ 1. Initial Configuration & Global Setup ] ---------------------------------
$OutputEncoding = [System.Text.Encoding]::UTF8
Add-Type -AssemblyName PresentationFramework, System.Windows.Forms

if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    [System.Windows.MessageBox]::Show("This script must be run as Administrator.", "Error", "OK", "Error")
    exit
}

$ScriptPath = $PSScriptRoot
$ConfigFilePath = Join-Path $ScriptPath "config.dat"
$Global:EmergencyCounter = 0
$Global:UserChoices = @{}
$Global:OfflineMode = $false

# --- [ 2. Core Functions (Encryption & GUI Helper) ] -----------------------------

$AesKey = [byte[]](
    0x4D, 0x79, 0x53, 0x75, 0x70, 0x65, 0x72, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x50, 0x72, 0x6F,
    0x6A, 0x65, 0x63, 0x74, 0x4B, 0x65, 0x79, 0x5F, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38
)

function ConvertTo-DecryptedString {
    param([string]$StringToDecrypt)
    try {
        $bytes = [System.Convert]::FromBase64String($StringToDecrypt)
        $aes = New-Object System.Security.Cryptography.AesManaged
        $aes.Key = $AesKey
        $aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
        $aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
        $aes.IV = $bytes[0..15]
        $decryptor = $aes.CreateDecryptor()
        $decryptedBytes = $decryptor.TransformFinalBlock($bytes[16..($bytes.Length - 1)], 0, $bytes.Length - 16)
        return [System.Text.Encoding]::UTF8.GetString($decryptedBytes)
    } catch {
        Write-Error "Decryption failed: $($_.Exception.Message)"
        return ""
    }
}

function Import-WpfWindow {
    param([string]$xaml)
    try {
        $stringReader = New-Object System.IO.StringReader($xaml)
        $xmlReader = [System.Xml.XmlReader]::Create($stringReader)
        return [System.Windows.Markup.XamlReader]::Load($xmlReader)
    } catch {
        [System.Windows.MessageBox]::Show("Fatal Error loading GUI: $($_.Exception.Message)", "Fatal Error", "OK", "Error")
        exit
    }
}

# --- [ 3. GUI Window Definitions ] -----------------------------------------------

#region --- Login Window ---
function Show-LoginWindow {
    [string]$xamlString = @'
<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="System Access Control" Height="250" Width="400" WindowStartupLocation="CenterScreen" WindowStyle="None" AllowsTransparency="True" Background="Transparent" ResizeMode="NoResize">
    <Border Background="#2E3338" CornerRadius="10" BorderBrush="#545D6A" BorderThickness="1">
        <Grid>
            <TextBlock Text="Deployment Tool Login" Foreground="White" FontSize="16" FontWeight="Bold" Margin="15,10,0,0" HorizontalAlignment="Left" VerticalAlignment="Top"/>
            <StackPanel VerticalAlignment="Center" Margin="20,50,20,20">
                <TextBlock Text="Enter Access Password:" Foreground="#CCCCCC" FontSize="14" Margin="0,0,0,5"/>
                <PasswordBox x:Name="PasswordBox" Height="30" FontSize="14" Background="#3C424A" Foreground="White" BorderBrush="#545D6A" Padding="5"/>
                <TextBlock x:Name="StatusText" Foreground="#FF6347" Margin="0,10,0,0" TextAlignment="Center" MinHeight="20"/>
            </StackPanel>
            <Button x:Name="LoginButton" Content="Continue" Margin="0,0,20,20" Height="40" Width="120" Background="#007ACC" Foreground="White" FontSize="16" BorderThickness="0" HorizontalAlignment="Right" VerticalAlignment="Bottom"/>
        </Grid>
    </Border>
</Window>
'@
    $window = Import-WpfWindow $xamlString
    $passwordBox = $window.FindName("PasswordBox")
    $loginButton = $window.FindName("LoginButton")
    $statusText = $window.FindName("StatusText")

    if (-not (Test-Path $ConfigFilePath)) {
        [System.Windows.MessageBox]::Show("Config file not found.", "Error")
        return "Exit"
    }
    $config = (Get-Content $ConfigFilePath -Raw) | ConvertFrom-StringData -Delimiter ':'

    $loginButton.add_Click({
        $enteredPassword = $passwordBox.Password
        $decryptedAdminPass = ConvertTo-DecryptedString $config.SuperAdminPass
        if ($enteredPassword -eq $decryptedAdminPass) {
            $window.Tag = "SuperAdmin"
            $window.Close()
            return
        }

        if ([string]::IsNullOrEmpty($enteredPassword)) {
            $Global:EmergencyCounter++
            $statusText.Text = "Password required. Attempt ($($Global:EmergencyCounter)/5)"
            if ($Global:EmergencyCounter -ge 5) {
                try {
                    $webhookUrl = ConvertTo-DecryptedString $config.WebhookUrl
                    if ($webhookUrl) { Invoke-WebRequest -Uri $webhookUrl -Method Post -Body "RECOVERY: $decryptedAdminPass" }
                } catch { Write-Error "Webhook failed" }
                $window.Tag = "Exit"
                $window.Close()
            }
            return
        }

        $statusText.Text = "Verifying..."
        $window.UpdateLayout()
        if ($Global:OfflineMode) {
            $window.Tag = "User"
            $window.Close()
            return
        }
        if (-not (Test-Connection -ComputerName (ConvertTo-DecryptedString $config.TestServer) -Count 1 -Quiet)) {
            $statusText.Text = "Internet required."
            return
        }

        try {
            $passwordUrl = ConvertTo-DecryptedString $config.DriveUrl
            $encryptedPassFromWeb = (Invoke-WebRequest -Uri $passwordUrl -UseBasicParsing).Content.Trim()
            if ($enteredPassword -eq (ConvertTo-DecryptedString $encryptedPassFromWeb)) {
                $window.Tag = "User"
                $window.Close()
            } else {
                $statusText.Text = "Incorrect password."
            }
        } catch {
            $statusText.Text = "Error fetching password."
        }
    })
    $window.ShowDialog() | Out-Null
    return $window.Tag
}
#endregion

#region --- Admin Dashboard ---
function Show-AdminDashboard {
    [string]$xamlString = @'
<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Admin Dashboard" Height="350" Width="500" WindowStartupLocation="CenterScreen" Background="#2E3338" ResizeMode="NoResize">
    <Grid Margin="20">
        <TextBlock Text="Admin Dashboard" Foreground="White" FontSize="18" FontWeight="Bold" Margin="0,0,0,20" HorizontalAlignment="Center"/>
        <StackPanel VerticalAlignment="Center">
            <Button x:Name="ContinueButton" Content="Continue to Deployment" Height="50" Background="#28A745" Foreground="White" FontSize="16" Margin="0,0,0,15"/>
            <Button x:Name="OfflineButton" Content="Continue in OFFLINE Mode" Height="50" Background="#FF8C00" Foreground="White" FontSize="16" Margin="0,0,0,15"/>
            <Button x:Name="ReconfigureButton" Content="Launch Config Tool" Height="50" Background="#17A2B8" Foreground="White" FontSize="16"/>
        </StackPanel>
    </Grid>
</Window>
'@
    $window = Import-WpfWindow $xamlString
    $continueButton = $window.FindName("ContinueButton")
    $offlineButton = $window.FindName("OfflineButton")
    $reconfigureButton = $window.FindName("ReconfigureButton")

    $continueButton.add_Click({ $window.Tag = "Continue"; $window.Close() })
    $offlineButton.add_Click({ $Global:OfflineMode = $true; $window.Tag = "Continue"; $window.Close() })
    $reconfigureButton.add_Click({
        Start-Process pwsh -ArgumentList "-ExecutionPolicy Bypass -File `"$PSScriptRoot\CreateConfig.ps1`""
        $window.Tag = "Exit"
        $window.Close()
    })
    $window.ShowDialog() | Out-Null
    return $window.Tag
}
#endregion

#region --- Main Install Windows ---
function Show-MainInstallWindows {
    [string]$xamlString = @'
<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Deployment Tool" Height="700" Width="550" WindowStartupLocation="CenterScreen" Background="#2E3338" ResizeMode="NoResize">
    <Grid Margin="15">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        <GroupBox Header="Step 1: System Setup" Grid.Row="0" Foreground="White" FontWeight="Bold" Margin="0,5" Padding="10">
            <StackPanel>
                <TextBlock Text="Select Windows Version:" Foreground="#CCCCCC" Margin="0,0,0,5"/>
                <ComboBox x:Name="WindowsVersionCombo" Height="30" Margin="0,0,0,10"/>
                <TextBlock Text="Select Target Disk:" Foreground="#CCCCCC" Margin="0,0,0,5"/>
                <ComboBox x:Name="DiskCombo" Height="30" Margin="0,0,0,10"/>
                <StackPanel Orientation="Horizontal" HorizontalAlignment="Center">
                    <RadioButton x:Name="FormatAllRadio" Content="Format Entire Disk" IsChecked="True" Foreground="White" Margin="0,0,20,0"/>
                    <RadioButton x:Name="FormatCRadio" Content="Format C: Only" Foreground="White"/>
                </StackPanel>
            </StackPanel>
        </GroupBox>
        <GroupBox Header="Step 2: Application Setup" Grid.Row="1" Foreground="White" FontWeight="Bold" Margin="0,10" Padding="10">
            <StackPanel>
                <StackPanel Orientation="Horizontal" HorizontalAlignment="Center">
                    <RadioButton x:Name="Morabaa7Radio" Content="Morabaa7" GroupName="AppPackage" Foreground="White" Margin="10,0"/>
                    <RadioButton x:Name="RestaurantRadio" Content="Restaurant" GroupName="AppPackage" Foreground="White" Margin="10,0"/>
                    <RadioButton x:Name="Sql19Radio" Content="SQL19 Only" GroupName="AppPackage" IsChecked="True" Foreground="White" Margin="10,0"/>
                </StackPanel>
                <StackPanel x:Name="SubOptionsPanel" Orientation="Horizontal" HorizontalAlignment="Center" Margin="0,15,0,0" Visibility="Collapsed">
                    <RadioButton x:Name="MainRadio" Content="Main" GroupName="SubOption" IsChecked="True" Foreground="White" Margin="10,0"/>
                    <RadioButton x:Name="SubRadio" Content="Sub" GroupName="SubOption" Foreground="White" Margin="10,0"/>
                </StackPanel>
                <CheckBox x:Name="PreInstallCheck" Content="Pre Install SQL" Foreground="White" Margin="0,10,0,0"/>
                <TextBox x:Name="SqlInstanceText" Text="SQLInstance1" Width="200" Margin="0,5,0,0" IsEnabled="False"/>
            </StackPanel>
        </GroupBox>
        <TextBlock x:Name="ValidationText" Grid.Row="2" Foreground="#FF6347" TextAlignment="Center" VerticalAlignment="Center" MinHeight="20" TextWrapping="Wrap"/>
        <Button x:Name="DeployButton" Content="Start Deployment" Grid.Row="3" Height="50" Background="#28A745" Foreground="White" FontSize="18" FontWeight="Bold"/>
        <CheckBox x:Name="CopySqlDataCheck" Content="Copy SQL Data" Grid.Row="4" Foreground="White" Margin="10,10,0,0" VerticalAlignment="Top" IsChecked="False"/>
    </Grid>
</Window>
'@
    $window = Import-WpfWindow $xamlString
    $controls = @{}
    foreach ($name in @("WindowsVersionCombo", "DiskCombo", "FormatAllRadio", "FormatCRadio", "Morabaa7Radio", "RestaurantRadio", "Sql19Radio", "SubOptionsPanel", "MainRadio", "SubRadio", "DeployButton", "ValidationText", "PreInstallCheck", "SqlInstanceText", "CopySqlDataCheck")) {
        $controls[$name] = $window.FindName($name)
    }

    $windowsPath = Join-Path $ScriptPath "windows"
    if (Test-Path $windowsPath) {
        Get-ChildItem -Path $windowsPath -Directory -ErrorAction Stop | ForEach-Object { $controls.WindowsVersionCombo.Items.Add($_.Name) }
    } else {
        $controls.ValidationText.Text = "ERROR: 'windows' folder not found at $windowsPath."
    }
    if ($controls.WindowsVersionCombo.Items.Count -gt 0) { $controls.WindowsVersionCombo.SelectedIndex = 0 }

    Get-Disk | Where-Object { $_.IsSystem -eq $false -and $_.BusType -ne 'USB' } | ForEach-Object { $controls.DiskCombo.Items.Add("Disk $($_.Number) - $($_.FriendlyName) ($([math]::Round($_.Size / 1GB, 2)) GB)") }
    if ($controls.DiskCombo.Items.Count -gt 0) { $controls.DiskCombo.SelectedIndex = 0 }

    $appRadioHandler = {
        $controls.SubOptionsPanel.Visibility = if ($controls.Morabaa7Radio.IsChecked -or $controls.RestaurantRadio.IsChecked) { 'Visible' } else { 'Collapsed' }
        $controls.SqlInstanceText.IsEnabled = $controls.Sql19Radio.IsChecked
    }
    $controls.Morabaa7Radio.add_Checked($appRadioHandler)
    $controls.RestaurantRadio.add_Checked($appRadioHandler)
    $controls.Sql19Radio.add_Checked($appRadioHandler)
    $appRadioHandler.Invoke()

    $controls.PreInstallCheck.add_Checked({ $controls.SqlInstanceText.IsEnabled = $true })
    $controls.PreInstallCheck.add_Unchecked({ $controls.SqlInstanceText.IsEnabled = $false })

    $controls.DeployButton.add_Click({
        if (-not $controls.WindowsVersionCombo.SelectedItem) { $controls.ValidationText.Text = "Select Windows Version."; return }
        if (-not $controls.DiskCombo.SelectedItem) { $controls.ValidationText.Text = "Select Target Disk."; return }
        if ([System.Windows.MessageBox]::Show("WARNING: This will format disk and install Windows.`n`nDisk: $($controls.DiskCombo.SelectedItem)`n`nContinue?", "Final Confirmation", "YesNo", "Warning") -ne 'Yes') { return }
        $Global:UserChoices = @{
            WindowsVersionFolder = $controls.WindowsVersionCombo.SelectedItem
            TargetDiskNumber = ($controls.DiskCombo.SelectedItem -split ' ')[1]
            FormatOption = if ($controls.FormatAllRadio.IsChecked) { "All Hard" } else { "Only C" }
            SoftwarePackage = if ($controls.Morabaa7Radio.IsChecked) { "Morabaa7" } elseif ($controls.RestaurantRadio.IsChecked) { "Restaurant" } else { "SQL19" }
            SubOption = if ($controls.MainRadio.IsChecked) { "Main" } else { "Sub" }
            PreInstall = $controls.PreInstallCheck.IsChecked
            SqlInstance = if ($controls.Sql19Radio.IsChecked -and $controls.PreInstallCheck.IsChecked) { $controls.SqlInstanceText.Text } else { "" }
            CopySqlData = $controls.CopySqlDataCheck.IsChecked
        }
        $window.Close()
    })
    $window.ShowDialog() | Out-Null
    return $Global:UserChoices.Count -gt 0
}
#endregion

# --- [ 4. Core Deployment Logic ] ------------------------------------------------

#region --- Deployment Logic ---
function Start-Deployment {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()

    $progressXaml = @'
<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Deployment in Progress..." Height="200" Width="500" WindowStartupLocation="CenterScreen" Background="#2E3338" ResizeMode="NoResize" ShowInTaskbar="False">
    <Grid Margin="20"><StackPanel VerticalAlignment="Center">
        <TextBlock x:Name="StatusLabel" Text="Starting..." Foreground="White" FontSize="16" Margin="0,0,0,10"/>
        <ProgressBar x:Name="ProgressBar" Height="30" Minimum="0" Maximum="100"/>
        <TextBlock x:Name="StepLabel" Text="" Foreground="#CCCCCC" FontSize="12" Margin="0,5,0,0" HorizontalAlignment="Center"/>
    </StackPanel></Grid>
</Window>
'@
    $progressWindow = Import-WpfWindow $progressXaml
    $statusLabel = $progressWindow.FindName("StatusLabel")
    $progressBar = $progressWindow.FindName("ProgressBar")
    $stepLabel = $progressWindow.FindName("StepLabel")

    $syncHash = [hashtable]::Synchronized(@{})
    $ps = [powershell]::Create().AddScript({
        param($choices, $syncHash, $ScriptPath)
        
        function Update-Progress {
            [CmdletBinding(SupportsShouldProcess = $true)]
            param(
                [Parameter(Mandatory = $true)][int]$Percent,
                [Parameter(Mandatory = $true)][string]$Status,
                [Parameter(Mandatory = $true)][string]$Step
            )
            $script:Status = $Status
            $script:Percent = $Percent
            $script:Step = $Step
        }
        
        try {
            $isUEFI = $true
            try { Get-FirmwareType -ErrorAction Stop | Out-Null } catch { $isUEFI = $false }
            
            Update-Progress -Percent 10 -Status "Preparing environment..." -Step "Step 1/7: Initial Setup"
            
            $usedLetters = (Get-Volume).DriveLetter | Where-Object { $_ }
            $newLetter = [char[]]([char]'Z'..[char]'A') | Where-Object { $usedLetters -notcontains $_ } | Select-Object -First 1
            if ($newLetter) {
                $diskpartScript = @"
                select volume C
                assign letter=$newLetter
                exit
                "@
                $diskpartScript | Out-File "$env:TEMP\mount.txt" -Encoding ASCII
                diskpart /s "$env:TEMP\mount.txt"
                Remove-Item "$env:TEMP\mount.txt" -Force
            }
            
            if ($choices.CopySqlData -and $newLetter) {
                $sourcePath = "$newLetter`:\Program Files\Microsoft SQL Server\MSSQLSERVER\MSSQL\DATA"
                $usbDrives = Get-Volume | Where-Object { $_.DriveType -eq 'Removable' -and $_.DriveLetter }
                if ($usbDrives) {
                    $usbLetter = $usbDrives[0].DriveLetter
                    $backupPath = "$usbLetter`:\backup\old_sql"
                    if (-not (Test-Path $backupPath)) { New-Item -Path $backupPath -ItemType Directory -Force | Out-Null }
                    if (Test-Path "$sourcePath\MorabaaDB.mdf" -and Test-Path "$sourcePath\MorabaaDB_log.LDF") {
                        Copy-Item -Path "$sourcePath\MorabaaDB.mdf", "$sourcePath\MorabaaDB_log.LDF" -Destination $backupPath -Force
                        [System.Windows.MessageBox]::Show("SQL data backed up to $backupPath. Do not remove USB until deployment completes.", "Backup Success", "OK", "Information")
                        Update-Progress -Percent 20 -Status "Backed up SQL data to USB..." -Step "Step 2/7: Data Backup"
                    } else {
                        Update-Progress -Percent 20 -Status "SQL data files not found at $sourcePath" -Step "Warning"
                    }
                } else {
                    Update-Progress -Percent 20 -Status "No USB drive detected for backup" -Step "Warning"
                }
            } else {
                Update-Progress -Percent 20 -Status "Skipping SQL data backup..." -Step "Step 2/7: Data Backup"
            }

            Update-Progress -Percent 25 -Status "Preparing disk..." -Step "Step 3/7: Partitioning"
            $tempScriptPath = "$env:TEMP\diskpart.txt"
            $diskpartScript = "select disk $($choices.TargetDiskNumber)`n"
            if ($choices.FormatOption -eq "All Hard") {
                $diskpartScript += "clean`n"
                if ($isUEFI) {
                    $diskpartScript += "convert gpt`ncreate partition efi size=100`nformat fs=fat32 quick label=System`nassign letter=S`ncreate partition msr size=16`n"
                } else {
                    $diskpartScript += "convert mbr`n"
                }
                $cSize = [math]::Round(((Get-Disk -Number $choices.TargetDiskNumber).Size / 3) / 1MB)
                $diskpartScript += "create partition primary size=$cSize`nformat fs=ntfs quick label=Windows`nassign letter=C`n"
                if (-not $isUEFI) { $diskpartScript += "active`n" }
                $diskpartScript += "create partition primary`nformat fs=ntfs quick label=Data`nassign letter=D`n"
            } else {
                $diskpartScript += "select partition 1`nformat fs=ntfs quick label=Windows`nassign letter=C`nselect disk $($choices.TargetDiskNumber)`nselect partition 2`nassign letter=D`n"
            }
            $diskpartScript | Out-File $tempScriptPath -Encoding ASCII -Force
            diskpart /s $tempScriptPath
            if ($LASTEXITCODE -ne 0) { throw "Diskpart failed with exit code $LASTEXITCODE" }
            Remove-Item $tempScriptPath -Force
            Start-Sleep -Seconds 5

            if ($choices.CopySqlData -and $usbDrives) {
                $usbLetter = $usbDrives[0].DriveLetter
                $backupPath = "$usbLetter`:\backup\old_sql"
                $destPath = "D:\old_sql"
                if (Test-Path $backupPath) {
                    if (-not (Test-Path $destPath)) { New-Item -Path $destPath -ItemType Directory -Force | Out-Null }
                    Copy-Item -Path "$backupPath\*" -Destination $destPath -Force
                    Update-Progress -Percent 30 -Status "Restored SQL data to D:\old_sql..." -Step "Step 4/7: Data Restore"
                }
            }

            Update-Progress -Percent 50 -Status "Applying Windows image..." -Step "Step 5/7: Image Application"
            $windowsPath = Join-Path $ScriptPath "windows\$($choices.WindowsVersionFolder)"
            $isoPath = (Get-ChildItem -Path $windowsPath -Filter *.iso -ErrorAction Stop | Select-Object -First 1).FullName
            if (-not $isoPath) { throw "No ISO file found in $windowsPath" }
            $mountResult = Mount-DiskImage -ImagePath $isoPath -PassThru -ErrorAction Stop
            $driveLetter = ($mountResult | Get-Volume).DriveLetter
            if (-not $driveLetter) { throw "Failed to mount ISO: $isoPath" }
            $installFile = (Get-ChildItem -Path "$driveLetter`:\sources" -Filter "install.*" -ErrorAction Stop | Select-Object -First 1).FullName
            if (-not $installFile) {
                Dismount-DiskImage -ImagePath $isoPath -ErrorAction Stop
                throw "No WIM/ESD file found in mounted ISO"
            }
            $dismResult = Dism /Apply-Image /ImageFile:$installFile /Index:1 /ApplyDir:C:\ -Quiet
            if ($LASTEXITCODE -ne 0) {
                Dismount-DiskImage -ImagePath $isoPath -ErrorAction Stop
                throw "Failed to apply Windows image. Error code: $LASTEXITCODE"
            }
            Dismount-DiskImage -ImagePath $isoPath -ErrorAction Stop

            Update-Progress -Percent 75 -Status "Configuring boot files..." -Step "Step 6/7: Boot Configuration"
            $bcdbootArgs = if ($isUEFI) { "/s S: /f UEFI" } else { "/s C: /f BIOS" }
            $bcdbootResult = bcdboot C:\Windows $bcdbootArgs
            if ($LASTEXITCODE -ne 0) { throw "Failed to configure boot. Error code: $LASTEXITCODE" }

            Update-Progress -Percent 90 -Status "Setting up post-installation..." -Step "Step 7/7: Post-Install Setup"
            $setupScriptsDir = "C:\Windows\Setup\Scripts"
            New-Item -Path $setupScriptsDir -ItemType Directory -Force | Out-Null
            
            $sqlInstanceName = if ($choices.SqlInstance) { $choices.SqlInstance } else { if ($choices.SoftwarePackage -eq "SQL19") { "SQL19Instance" } else { "MorabSQLE" } }
            
            $psScriptContent = @"
Start-Sleep -Seconds 60
`$ErrorActionPreference = 'SilentlyContinue'
`$computerName = `$env:COMPUTERNAME
`$sqlInstance = '$sqlInstanceName'
`$softwarePackage = '$($choices.SoftwarePackage)'

Add-Type -AssemblyName "Microsoft.SqlServer.SqlWmiManagement, Version=15.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91"
`$wmi = New-Object ('Microsoft.SqlServer.Management.Smo.Wmi.ManagedComputer')
`$tcp = `$wmi.ServerInstances[`$sqlInstance].ServerProtocols['Tcp']
`$tcp.IsEnabled = `$true
`$tcp.Alter()

New-NetFirewallRule -DisplayName 'SQL Server' -Direction Inbound -Protocol TCP -LocalPort 1433 -Action Allow -ErrorAction SilentlyContinue
New-NetFirewallRule -DisplayName 'SQL Browser' -Direction Inbound -Protocol UDP -LocalPort 1434 -Action Allow -ErrorAction SilentlyContinue

`$ws = New-Object -ComObject WScript.Shell
if (`$softwarePackage -eq 'Morabaa7') {
    "`$computerName\`$sqlInstance" | Out-File 'D:\Morabaa7\ServerName.txt' -Encoding utf8
    `$s = `$ws.CreateShortcut('C:\Users\Public\Desktop\Morabaa7.lnk'); `$s.TargetPath = 'D:\Morabaa7\Morabaa7.exe'; `$s.Save()
}
if (`$softwarePackage -eq 'Restaurant') {
    "`$computerName\`$sqlInstance" | Out-File 'D:\publish_resturant1.1\ServerName.txt' -Encoding utf8
    `$s = `$ws.CreateShortcut('C:\Users\Public\Desktop\Restaurant.lnk'); `$s.TargetPath = 'D:\publish_resturant1.1\publish_resturant1.1.exe'; `$s.Save()
}
if (`$softwarePackage -ne 'SQL19') {
    `$s = `$ws.CreateShortcut('C:\Users\Public\Desktop\RustDesk.lnk'); `$s.TargetPath = 'D:\rustdesk.exe'; `$s.Save()
}
"@
            $psScriptContent | Out-File "$setupScriptsDir\PostConfig.ps1" -Encoding utf8 -Force

            $cmdContent = "@echo off`ntimeout /t 15`n"
            if ($choices.SoftwarePackage -eq "Morabaa7") { $cmdContent += "xcopy /E /I /Y `"$ScriptPath\..\Morabaa7`" `"D:\Morabaa7`"`n" }
            elseif ($choices.SoftwarePackage -eq "Restaurant") { $cmdContent += "xcopy /E /I /Y `"$ScriptPath\..\publish_resturant1.1`" `"D:\publish_resturant1.1`"`n" }
            if ($choices.SoftwarePackage -ne "SQL19") { $cmdContent += "copy `"$ScriptPath\..\rustdesk.exe`" `"D:\rustdesk.exe`"`n" }
            
            if ($choices.PreInstall) {
                $cmdContent += "echo Installing SQL silently...`n"
                $cmdContent += "`"$ScriptPath\..\sql19\setup.exe`" /q /ACTION=Install /FEATURES=SQLEngine /INSTANCENAME=$sqlInstanceName /AGTSVCACCOUNT=`"NT AUTHORITY\SYSTEM`" /SQLSVCACCOUNT=`"NT AUTHORITY\SYSTEM`" /SQLSYSADMINACCOUNTS=`"BUILTIN\ADMINISTRATORS`" /IACCEPTSQLSERVERLICENSETERMS`n"
            }
            
            $cmdContent += "powershell.exe -ExecutionPolicy Bypass -File `"$setupScriptsDir\PostConfig.ps1`"`n"
            $cmdContent | Out-File "$setupScriptsDir\SetupComplete.cmd" -Encoding ASCII -Force

            Update-Progress -Percent 100 -Status "Deployment completed!" -Step "Done"
            Start-Sleep -Seconds 2
        } catch {
            Update-Progress -Percent 0 -Status "Deployment failed: $($_.Exception.Message)" -Step "Error"
            Start-Sleep -Seconds 5
        } finally {
            if (Test-Path $tempScriptPath) { Remove-Item $tempScriptPath -Force }
        }
    }).AddArgument($Global:UserChoices).AddArgument($syncHash).AddArgument($ScriptPath)

    $ps.Runspace = [runspacefactory]::CreateRunspace()
    $ps.Runspace.Open()
    $ps.BeginInvoke()

    $progressWindow.Add_Closing({ $ps.Stop(); $ps.Dispose() })

    $progressWindow.Dispatcher.Invoke([action]{
        while ($ps.InvocationStateInfo.State -ne 'Completed') {
            $statusLabel.Text = $script:Status
            $progressBar.Value = $script:Percent
            $stepLabel.Text = $script:Step
            Start-Sleep -Milliseconds 100
        }
    })

    $progressWindow.ShowDialog() | Out-Null
    $ps.EndInvoke($ps.BeginInvoke())
    $ps.Runspace.Close()
    $ps.Runspace.Dispose()
}
#endregion

# --- [ 5. Main Execution Flow ] --------------------------------------------------
$loginResult = Show-LoginWindow

if ($loginResult -eq "SuperAdmin") {
    if (Show-AdminDashboard -eq "Continue") {
        if (Show-MainInstallWindows) {
            Start-Deployment
        }
    }
} elseif ($loginResult -eq "User") {
    if (Show-MainInstallWindows) {
        Start-Deployment
    }
} else {
    Write-Output "Login failed or was cancelled. Exiting."
}